{"version":3,"sources":["../src/index.ts","../src/errors.ts","../src/crypto.ts","../src/client.ts"],"sourcesContent":["/**\n * Tether Name SDK - Official Node.js library for tether.name agent identity verification\n * \n * @example\n * ```typescript\n * import { TetherClient } from 'tether-name';\n * \n * const client = new TetherClient({\n *   credentialId: 'your-credential-id',\n *   privateKeyPath: '/path/to/key.der'\n * });\n * \n * const result = await client.verify();\n * console.log(result.verified, result.agentName);\n * ```\n */\n\n// Main exports\nexport { TetherClient } from './client.js';\n\n// Types\nexport type {\n  TetherClientConfig,\n  ChallengeResponse,\n  Agent,\n  IssueCredentialResponse,\n  VerificationRequest,\n  VerificationResponse,\n  VerificationResult,\n  KeyFormat\n} from './types.js';\n\n// Errors\nexport {\n  TetherError,\n  TetherAPIError,\n  TetherVerificationError\n} from './errors.js';\n\n// Crypto utilities (for advanced use cases)\nexport {\n  loadPrivateKey,\n  signChallenge,\n  detectKeyFormat\n} from './crypto.js';","/**\n * Base error class for all Tether-related errors\n */\nexport class TetherError extends Error {\n  constructor(message: string, public readonly cause?: Error) {\n    super(message);\n    this.name = 'TetherError';\n    \n    // Maintain proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, TetherError);\n    }\n  }\n}\n\n/**\n * Error thrown when verification fails\n */\nexport class TetherVerificationError extends TetherError {\n  constructor(message: string, cause?: Error) {\n    super(message, cause);\n    this.name = 'TetherVerificationError';\n  }\n}\n\n/**\n * Error thrown when API requests fail\n */\nexport class TetherAPIError extends TetherError {\n  constructor(\n    message: string,\n    public readonly status?: number,\n    public readonly response?: string,\n    cause?: Error\n  ) {\n    super(message, cause);\n    this.name = 'TetherAPIError';\n  }\n}","import { createSign, createPrivateKey, KeyObject } from 'crypto';\nimport { readFileSync } from 'fs';\nimport { TetherError } from './errors.js';\nimport type { KeyFormat } from './types.js';\n\n/**\n * Imports a DER-encoded private key, trying PKCS#8 first then PKCS#1.\n */\nfunction importDerKey(derData: Buffer): KeyObject {\n  try {\n    return createPrivateKey({ key: derData, format: 'der', type: 'pkcs8' });\n  } catch {\n    // PKCS#8 failed — try PKCS#1\n  }\n  try {\n    return createPrivateKey({ key: derData, format: 'der', type: 'pkcs1' });\n  } catch {\n    // PKCS#1 also failed\n  }\n  throw new TetherError(\n    'Failed to load DER private key: data is not valid PKCS#8 or PKCS#1. ' +\n    'Ensure the file is an RSA private key in DER format.'\n  );\n}\n\n/**\n * Loads a private key from various sources\n */\nexport function loadPrivateKey(options: {\n  keyPath?: string;\n  keyPem?: string;\n  keyBuffer?: Buffer;\n}): KeyObject {\n  const { keyPath, keyPem, keyBuffer } = options;\n\n  try {\n    if (keyPem) {\n      // PEM string provided directly\n      return createPrivateKey(keyPem);\n    }\n\n    if (keyBuffer) {\n      // DER buffer provided directly\n      return importDerKey(keyBuffer);\n    }\n\n    if (keyPath) {\n      // Read from file - detect format by extension or content\n      const keyData = readFileSync(keyPath);\n\n      // Try to detect format\n      if (keyPath.endsWith('.pem') || keyData.toString().includes('-----BEGIN')) {\n        // PEM format\n        return createPrivateKey(keyData);\n      } else {\n        // Assume DER format\n        return importDerKey(keyData);\n      }\n    }\n\n    throw new TetherError('No private key provided');\n  } catch (error) {\n    if (error instanceof TetherError) {\n      throw error;\n    }\n    throw new TetherError(\n      `Failed to load private key: ${error instanceof Error ? error.message : String(error)}`,\n      error instanceof Error ? error : undefined\n    );\n  }\n}\n\n/**\n * Signs a challenge string using RSA-SHA256\n * Returns URL-safe base64 encoded signature (no padding)\n */\nexport function signChallenge(privateKey: KeyObject, challenge: string): string {\n  try {\n    const sign = createSign('SHA256');\n    sign.update(challenge);\n    sign.end();\n    \n    const signature = sign.sign(privateKey);\n    \n    // Convert to URL-safe base64 without padding\n    return signature\n      .toString('base64')\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n      .replace(/=/g, '');\n  } catch (error) {\n    throw new TetherError(\n      `Failed to sign challenge: ${error instanceof Error ? error.message : String(error)}`,\n      error instanceof Error ? error : undefined\n    );\n  }\n}\n\n/**\n * Utility function to detect key format from file extension or content\n */\nexport function detectKeyFormat(keyPath: string): KeyFormat {\n  if (keyPath.endsWith('.pem')) {\n    return 'pem';\n  }\n  if (keyPath.endsWith('.der')) {\n    return 'der';\n  }\n  \n  // Try to read a small portion to detect format\n  try {\n    const keyData = readFileSync(keyPath, { encoding: 'utf8', flag: 'r' });\n    if (keyData.includes('-----BEGIN')) {\n      return 'pem';\n    }\n  } catch {\n    // If we can't read as text, it's probably DER\n  }\n  \n  return 'der';\n}","import { KeyObject } from 'crypto';\nimport { TetherError, TetherAPIError, TetherVerificationError } from './errors.js';\nimport { loadPrivateKey, signChallenge } from './crypto.js';\nimport type {\n  TetherClientConfig,\n  ChallengeResponse,\n  Agent,\n  IssueCredentialResponse,\n  VerificationRequest,\n  VerificationResponse,\n  VerificationResult\n} from './types.js';\n\n/**\n * TetherClient - Official SDK for tether.name agent identity verification\n */\nexport class TetherClient {\n  private readonly credentialId: string;\n  private readonly privateKey: KeyObject | null;\n  private readonly baseUrl: string;\n  private readonly apiKey?: string;\n\n  constructor(config: TetherClientConfig) {\n    // Set base URL\n    this.baseUrl = config.baseUrl || 'https://api.tether.name';\n\n    // Get API key from config or environment\n    this.apiKey = config.apiKey || process.env.TETHER_API_KEY;\n\n    // Get credential ID from config or environment\n    this.credentialId = config.credentialId || process.env.TETHER_CREDENTIAL_ID || '';\n\n    // Load private key if key material is provided\n    const keyPath = config.privateKeyPath || process.env.TETHER_PRIVATE_KEY_PATH;\n    const hasKeyMaterial = keyPath || config.privateKeyPem || config.privateKeyBuffer;\n\n    if (hasKeyMaterial) {\n      this.privateKey = loadPrivateKey({\n        keyPath,\n        keyPem: config.privateKeyPem,\n        keyBuffer: config.privateKeyBuffer\n      });\n    } else {\n      this.privateKey = null;\n    }\n\n    // If no API key and no private key, credential ID and key are still needed for verify/sign\n    // but we defer the error to when those methods are called\n    if (!this.apiKey && !this.privateKey) {\n      // Allow construction — errors thrown at method call time\n    }\n\n    if (!this.apiKey && !this.credentialId) {\n      // Allow construction — errors thrown at method call time\n    }\n  }\n\n  /**\n   * Returns authorization headers when an API key is configured\n   */\n  private _authHeaders(): Record<string, string> {\n    if (this.apiKey) {\n      return { 'Authorization': `Bearer ${this.apiKey}` };\n    }\n    return {};\n  }\n\n  /**\n   * Ensures a private key is available, throwing if not\n   */\n  private _requirePrivateKey(): KeyObject {\n    if (!this.privateKey) {\n      throw new TetherError(\n        'Private key is required for this operation. Provide privateKeyPath, privateKeyPem, or privateKeyBuffer in config, or set TETHER_PRIVATE_KEY_PATH environment variable.'\n      );\n    }\n    return this.privateKey;\n  }\n\n  /**\n   * Ensures an API key is available, throwing if not\n   */\n  private _requireApiKey(): void {\n    if (!this.apiKey) {\n      throw new TetherError(\n        'API key is required for agent management operations. Provide apiKey in config or set TETHER_API_KEY environment variable.'\n      );\n    }\n  }\n\n  /**\n   * Ensures a credential ID is available, throwing if not\n   */\n  private _requireCredentialId(): string {\n    if (!this.credentialId) {\n      throw new TetherError(\n        'Credential ID is required for this operation. Provide it in config or set TETHER_CREDENTIAL_ID environment variable.'\n      );\n    }\n    return this.credentialId;\n  }\n\n  /**\n   * Request a challenge from the Tether API\n   */\n  async requestChallenge(): Promise<string> {\n    try {\n      const response = await fetch(`${this.baseUrl}/challenge`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text().catch(() => 'Unknown error');\n        throw new TetherAPIError(\n          `Challenge request failed: ${response.status} ${response.statusText}`,\n          response.status,\n          errorText\n        );\n      }\n\n      const data = await response.json() as ChallengeResponse;\n\n      if (!data.code) {\n        throw new TetherAPIError('Invalid challenge response: missing code');\n      }\n\n      return data.code;\n    } catch (error) {\n      if (error instanceof TetherError) {\n        throw error;\n      }\n      throw new TetherAPIError(\n        `Failed to request challenge: ${error instanceof Error ? error.message : String(error)}`,\n        undefined,\n        undefined,\n        error instanceof Error ? error : undefined\n      );\n    }\n  }\n\n  /**\n   * Sign a challenge string\n   */\n  sign(challenge: string): string {\n    const key = this._requirePrivateKey();\n    return signChallenge(key, challenge);\n  }\n\n  /**\n   * Submit proof for a challenge\n   */\n  async submitProof(challenge: string, proof: string): Promise<VerificationResult> {\n    const credentialId = this._requireCredentialId();\n\n    try {\n      const payload: VerificationRequest = {\n        challenge,\n        proof,\n        credentialId\n      };\n\n      const response = await fetch(`${this.baseUrl}/challenge/verify`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(payload)\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text().catch(() => 'Unknown error');\n        throw new TetherAPIError(\n          `Verification failed: ${response.status} ${response.statusText}`,\n          response.status,\n          errorText\n        );\n      }\n\n      const data = await response.json() as VerificationResponse;\n\n      // Convert API response to our result format\n      return {\n        verified: data.valid,\n        agentName: data.agentName,\n        verifyUrl: data.verifyUrl,\n        email: data.email,\n        registeredSince: data.registeredSince,\n        error: data.error,\n        challenge\n      };\n    } catch (error) {\n      if (error instanceof TetherError) {\n        throw error;\n      }\n      throw new TetherAPIError(\n        `Failed to submit proof: ${error instanceof Error ? error.message : String(error)}`,\n        undefined,\n        undefined,\n        error instanceof Error ? error : undefined\n      );\n    }\n  }\n\n  /**\n   * Perform complete verification in one call\n   */\n  async verify(): Promise<VerificationResult> {\n    try {\n      const challenge = await this.requestChallenge();\n      const proof = this.sign(challenge);\n      const result = await this.submitProof(challenge, proof);\n\n      if (!result.verified) {\n        throw new TetherVerificationError(\n          result.error || 'Verification failed for unknown reason'\n        );\n      }\n\n      return result;\n    } catch (error) {\n      if (error instanceof TetherError) {\n        throw error;\n      }\n      throw new TetherVerificationError(\n        `Verification failed: ${error instanceof Error ? error.message : String(error)}`,\n        error instanceof Error ? error : undefined\n      );\n    }\n  }\n\n  /**\n   * Create a new agent\n   */\n  async createAgent(agentName: string, description: string = ''): Promise<Agent> {\n    this._requireApiKey();\n    try {\n      const response = await fetch(`${this.baseUrl}/credentials/issue`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...this._authHeaders()\n        },\n        body: JSON.stringify({ agentName, description })\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text().catch(() => 'Unknown error');\n        throw new TetherAPIError(\n          `Create agent failed: ${response.status} ${response.statusText}`,\n          response.status,\n          errorText\n        );\n      }\n\n      const data = await response.json() as IssueCredentialResponse;\n      return data;\n    } catch (error) {\n      if (error instanceof TetherError) {\n        throw error;\n      }\n      throw new TetherAPIError(\n        `Failed to create agent: ${error instanceof Error ? error.message : String(error)}`,\n        undefined,\n        undefined,\n        error instanceof Error ? error : undefined\n      );\n    }\n  }\n\n  /**\n   * List all agents\n   */\n  async listAgents(): Promise<Agent[]> {\n    this._requireApiKey();\n    try {\n      const response = await fetch(`${this.baseUrl}/credentials`, {\n        method: 'GET',\n        headers: {\n          ...this._authHeaders()\n        }\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text().catch(() => 'Unknown error');\n        throw new TetherAPIError(\n          `List agents failed: ${response.status} ${response.statusText}`,\n          response.status,\n          errorText\n        );\n      }\n\n      const data = await response.json() as Agent[];\n      return data;\n    } catch (error) {\n      if (error instanceof TetherError) {\n        throw error;\n      }\n      throw new TetherAPIError(\n        `Failed to list agents: ${error instanceof Error ? error.message : String(error)}`,\n        undefined,\n        undefined,\n        error instanceof Error ? error : undefined\n      );\n    }\n  }\n\n  /**\n   * Delete an agent by ID\n   */\n  async deleteAgent(agentId: string): Promise<boolean> {\n    this._requireApiKey();\n    try {\n      const response = await fetch(`${this.baseUrl}/credentials/${agentId}`, {\n        method: 'DELETE',\n        headers: {\n          ...this._authHeaders()\n        }\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text().catch(() => 'Unknown error');\n        throw new TetherAPIError(\n          `Delete agent failed: ${response.status} ${response.statusText}`,\n          response.status,\n          errorText\n        );\n      }\n\n      return true;\n    } catch (error) {\n      if (error instanceof TetherError) {\n        throw error;\n      }\n      throw new TetherAPIError(\n        `Failed to delete agent: ${error instanceof Error ? error.message : String(error)}`,\n        undefined,\n        undefined,\n        error instanceof Error ? error : undefined\n      );\n    }\n  }\n}"],"mappings":"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","names":[]}
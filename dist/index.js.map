{"version":3,"sources":["../src/index.ts","../src/errors.ts","../src/crypto.ts","../src/client.ts"],"sourcesContent":["/**\n * Tether Name SDK - Official Node.js library for tether.name agent identity verification\n * \n * @example\n * ```typescript\n * import { TetherClient } from 'tether-name';\n * \n * const client = new TetherClient({\n *   credentialId: 'your-credential-id',\n *   privateKeyPath: '/path/to/key.der'\n * });\n * \n * const result = await client.verify();\n * console.log(result.verified, result.agentName);\n * ```\n */\n\n// Main exports\nexport { TetherClient } from './client.js';\n\n// Types\nexport type {\n  TetherClientConfig,\n  ChallengeResponse,\n  VerificationRequest,\n  VerificationResponse,\n  VerificationResult,\n  KeyFormat\n} from './types.js';\n\n// Errors\nexport {\n  TetherError,\n  TetherAPIError,\n  TetherVerificationError\n} from './errors.js';\n\n// Crypto utilities (for advanced use cases)\nexport {\n  loadPrivateKey,\n  signChallenge,\n  detectKeyFormat\n} from './crypto.js';","/**\n * Base error class for all Tether-related errors\n */\nexport class TetherError extends Error {\n  constructor(message: string, public readonly cause?: Error) {\n    super(message);\n    this.name = 'TetherError';\n    \n    // Maintain proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, TetherError);\n    }\n  }\n}\n\n/**\n * Error thrown when verification fails\n */\nexport class TetherVerificationError extends TetherError {\n  constructor(message: string, cause?: Error) {\n    super(message, cause);\n    this.name = 'TetherVerificationError';\n  }\n}\n\n/**\n * Error thrown when API requests fail\n */\nexport class TetherAPIError extends TetherError {\n  constructor(\n    message: string,\n    public readonly status?: number,\n    public readonly response?: string,\n    cause?: Error\n  ) {\n    super(message, cause);\n    this.name = 'TetherAPIError';\n  }\n}","import { createSign, createPrivateKey, KeyObject } from 'crypto';\nimport { readFileSync } from 'fs';\nimport { TetherError } from './errors.js';\nimport type { KeyFormat } from './types.js';\n\n/**\n * Loads a private key from various sources\n */\nexport function loadPrivateKey(options: {\n  keyPath?: string;\n  keyPem?: string;\n  keyBuffer?: Buffer;\n}): KeyObject {\n  const { keyPath, keyPem, keyBuffer } = options;\n\n  try {\n    if (keyPem) {\n      // PEM string provided directly\n      return createPrivateKey(keyPem);\n    }\n    \n    if (keyBuffer) {\n      // DER buffer provided directly\n      return createPrivateKey({\n        key: keyBuffer,\n        format: 'der',\n        type: 'pkcs1'\n      });\n    }\n    \n    if (keyPath) {\n      // Read from file - detect format by extension or content\n      const keyData = readFileSync(keyPath);\n      \n      // Try to detect format\n      if (keyPath.endsWith('.pem') || keyData.toString().includes('-----BEGIN')) {\n        // PEM format\n        return createPrivateKey(keyData);\n      } else {\n        // Assume DER format\n        return createPrivateKey({\n          key: keyData,\n          format: 'der',\n          type: 'pkcs1'\n        });\n      }\n    }\n    \n    throw new TetherError('No private key provided');\n  } catch (error) {\n    if (error instanceof TetherError) {\n      throw error;\n    }\n    throw new TetherError(\n      `Failed to load private key: ${error instanceof Error ? error.message : String(error)}`,\n      error instanceof Error ? error : undefined\n    );\n  }\n}\n\n/**\n * Signs a challenge string using RSA-SHA256\n * Returns URL-safe base64 encoded signature (no padding)\n */\nexport function signChallenge(privateKey: KeyObject, challenge: string): string {\n  try {\n    const sign = createSign('SHA256');\n    sign.update(challenge);\n    sign.end();\n    \n    const signature = sign.sign(privateKey);\n    \n    // Convert to URL-safe base64 without padding\n    return signature\n      .toString('base64')\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n      .replace(/=/g, '');\n  } catch (error) {\n    throw new TetherError(\n      `Failed to sign challenge: ${error instanceof Error ? error.message : String(error)}`,\n      error instanceof Error ? error : undefined\n    );\n  }\n}\n\n/**\n * Utility function to detect key format from file extension or content\n */\nexport function detectKeyFormat(keyPath: string): KeyFormat {\n  if (keyPath.endsWith('.pem')) {\n    return 'pem';\n  }\n  if (keyPath.endsWith('.der')) {\n    return 'der';\n  }\n  \n  // Try to read a small portion to detect format\n  try {\n    const keyData = readFileSync(keyPath, { encoding: 'utf8', flag: 'r' });\n    if (keyData.includes('-----BEGIN')) {\n      return 'pem';\n    }\n  } catch {\n    // If we can't read as text, it's probably DER\n  }\n  \n  return 'der';\n}","import { KeyObject } from 'crypto';\nimport { TetherError, TetherAPIError, TetherVerificationError } from './errors.js';\nimport { loadPrivateKey, signChallenge } from './crypto.js';\nimport type {\n  TetherClientConfig,\n  ChallengeResponse,\n  VerificationRequest,\n  VerificationResponse,\n  VerificationResult\n} from './types.js';\n\n/**\n * TetherClient - Official SDK for tether.name agent identity verification\n */\nexport class TetherClient {\n  private readonly credentialId: string;\n  private readonly privateKey: KeyObject;\n  private readonly baseUrl: string;\n\n  constructor(config: TetherClientConfig) {\n    // Get credential ID from config or environment\n    this.credentialId = config.credentialId || process.env.TETHER_CREDENTIAL_ID || '';\n    if (!this.credentialId) {\n      throw new TetherError('Credential ID is required. Provide it in config or set TETHER_CREDENTIAL_ID environment variable.');\n    }\n\n    // Load private key\n    const keyPath = config.privateKeyPath || process.env.TETHER_PRIVATE_KEY_PATH;\n    this.privateKey = loadPrivateKey({\n      keyPath,\n      keyPem: config.privateKeyPem,\n      keyBuffer: config.privateKeyBuffer\n    });\n\n    // Set base URL\n    this.baseUrl = config.baseUrl || 'https://api.tether.name';\n  }\n\n  /**\n   * Request a challenge from the Tether API\n   */\n  async requestChallenge(): Promise<string> {\n    try {\n      const response = await fetch(`${this.baseUrl}/challenge`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text().catch(() => 'Unknown error');\n        throw new TetherAPIError(\n          `Challenge request failed: ${response.status} ${response.statusText}`,\n          response.status,\n          errorText\n        );\n      }\n\n      const data = await response.json() as ChallengeResponse;\n      \n      if (!data.code) {\n        throw new TetherAPIError('Invalid challenge response: missing code');\n      }\n\n      return data.code;\n    } catch (error) {\n      if (error instanceof TetherError) {\n        throw error;\n      }\n      throw new TetherAPIError(\n        `Failed to request challenge: ${error instanceof Error ? error.message : String(error)}`,\n        undefined,\n        undefined,\n        error instanceof Error ? error : undefined\n      );\n    }\n  }\n\n  /**\n   * Sign a challenge string\n   */\n  sign(challenge: string): string {\n    return signChallenge(this.privateKey, challenge);\n  }\n\n  /**\n   * Submit proof for a challenge\n   */\n  async submitProof(challenge: string, proof: string): Promise<VerificationResult> {\n    try {\n      const payload: VerificationRequest = {\n        challenge,\n        proof,\n        credentialId: this.credentialId\n      };\n\n      const response = await fetch(`${this.baseUrl}/challenge/verify`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(payload)\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text().catch(() => 'Unknown error');\n        throw new TetherAPIError(\n          `Verification failed: ${response.status} ${response.statusText}`,\n          response.status,\n          errorText\n        );\n      }\n\n      const data = await response.json() as VerificationResponse;\n\n      // Convert API response to our result format\n      return {\n        verified: data.valid,\n        agentName: data.agentName,\n        verifyUrl: data.verifyUrl,\n        email: data.email,\n        registeredSince: data.registeredSince,\n        error: data.error,\n        challenge\n      };\n    } catch (error) {\n      if (error instanceof TetherError) {\n        throw error;\n      }\n      throw new TetherAPIError(\n        `Failed to submit proof: ${error instanceof Error ? error.message : String(error)}`,\n        undefined,\n        undefined,\n        error instanceof Error ? error : undefined\n      );\n    }\n  }\n\n  /**\n   * Perform complete verification in one call\n   */\n  async verify(): Promise<VerificationResult> {\n    try {\n      const challenge = await this.requestChallenge();\n      const proof = this.sign(challenge);\n      const result = await this.submitProof(challenge, proof);\n\n      if (!result.verified) {\n        throw new TetherVerificationError(\n          result.error || 'Verification failed for unknown reason'\n        );\n      }\n\n      return result;\n    } catch (error) {\n      if (error instanceof TetherError) {\n        throw error;\n      }\n      throw new TetherVerificationError(\n        `Verification failed: ${error instanceof Error ? error.message : String(error)}`,\n        error instanceof Error ? error : undefined\n      );\n    }\n  }\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACGO,IAAM,cAAN,MAAM,qBAAoB,MAAM;AAAA,EACrC,YAAY,SAAiC,OAAe;AAC1D,UAAM,OAAO;AAD8B;AAE3C,SAAK,OAAO;AAGZ,QAAI,MAAM,mBAAmB;AAC3B,YAAM,kBAAkB,MAAM,YAAW;AAAA,IAC3C;AAAA,EACF;AACF;AAKO,IAAM,0BAAN,cAAsC,YAAY;AAAA,EACvD,YAAY,SAAiB,OAAe;AAC1C,UAAM,SAAS,KAAK;AACpB,SAAK,OAAO;AAAA,EACd;AACF;AAKO,IAAM,iBAAN,cAA6B,YAAY;AAAA,EAC9C,YACE,SACgB,QACA,UAChB,OACA;AACA,UAAM,SAAS,KAAK;AAJJ;AACA;AAIhB,SAAK,OAAO;AAAA,EACd;AACF;;;ACtCA,oBAAwD;AACxD,gBAA6B;AAOtB,SAAS,eAAe,SAIjB;AACZ,QAAM,EAAE,SAAS,QAAQ,UAAU,IAAI;AAEvC,MAAI;AACF,QAAI,QAAQ;AAEV,iBAAO,gCAAiB,MAAM;AAAA,IAChC;AAEA,QAAI,WAAW;AAEb,iBAAO,gCAAiB;AAAA,QACtB,KAAK;AAAA,QACL,QAAQ;AAAA,QACR,MAAM;AAAA,MACR,CAAC;AAAA,IACH;AAEA,QAAI,SAAS;AAEX,YAAM,cAAU,wBAAa,OAAO;AAGpC,UAAI,QAAQ,SAAS,MAAM,KAAK,QAAQ,SAAS,EAAE,SAAS,YAAY,GAAG;AAEzE,mBAAO,gCAAiB,OAAO;AAAA,MACjC,OAAO;AAEL,mBAAO,gCAAiB;AAAA,UACtB,KAAK;AAAA,UACL,QAAQ;AAAA,UACR,MAAM;AAAA,QACR,CAAC;AAAA,MACH;AAAA,IACF;AAEA,UAAM,IAAI,YAAY,yBAAyB;AAAA,EACjD,SAAS,OAAO;AACd,QAAI,iBAAiB,aAAa;AAChC,YAAM;AAAA,IACR;AACA,UAAM,IAAI;AAAA,MACR,+BAA+B,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,MACrF,iBAAiB,QAAQ,QAAQ;AAAA,IACnC;AAAA,EACF;AACF;AAMO,SAAS,cAAc,YAAuB,WAA2B;AAC9E,MAAI;AACF,UAAM,WAAO,0BAAW,QAAQ;AAChC,SAAK,OAAO,SAAS;AACrB,SAAK,IAAI;AAET,UAAM,YAAY,KAAK,KAAK,UAAU;AAGtC,WAAO,UACJ,SAAS,QAAQ,EACjB,QAAQ,OAAO,GAAG,EAClB,QAAQ,OAAO,GAAG,EAClB,QAAQ,MAAM,EAAE;AAAA,EACrB,SAAS,OAAO;AACd,UAAM,IAAI;AAAA,MACR,6BAA6B,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,MACnF,iBAAiB,QAAQ,QAAQ;AAAA,IACnC;AAAA,EACF;AACF;AAKO,SAAS,gBAAgB,SAA4B;AAC1D,MAAI,QAAQ,SAAS,MAAM,GAAG;AAC5B,WAAO;AAAA,EACT;AACA,MAAI,QAAQ,SAAS,MAAM,GAAG;AAC5B,WAAO;AAAA,EACT;AAGA,MAAI;AACF,UAAM,cAAU,wBAAa,SAAS,EAAE,UAAU,QAAQ,MAAM,IAAI,CAAC;AACrE,QAAI,QAAQ,SAAS,YAAY,GAAG;AAClC,aAAO;AAAA,IACT;AAAA,EACF,QAAQ;AAAA,EAER;AAEA,SAAO;AACT;;;AC9FO,IAAM,eAAN,MAAmB;AAAA,EACP;AAAA,EACA;AAAA,EACA;AAAA,EAEjB,YAAY,QAA4B;AAEtC,SAAK,eAAe,OAAO,gBAAgB,QAAQ,IAAI,wBAAwB;AAC/E,QAAI,CAAC,KAAK,cAAc;AACtB,YAAM,IAAI,YAAY,mGAAmG;AAAA,IAC3H;AAGA,UAAM,UAAU,OAAO,kBAAkB,QAAQ,IAAI;AACrD,SAAK,aAAa,eAAe;AAAA,MAC/B;AAAA,MACA,QAAQ,OAAO;AAAA,MACf,WAAW,OAAO;AAAA,IACpB,CAAC;AAGD,SAAK,UAAU,OAAO,WAAW;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,mBAAoC;AACxC,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,cAAc;AAAA,QACxD,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,QAClB;AAAA,MACF,CAAC;AAED,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,YAAY,MAAM,SAAS,KAAK,EAAE,MAAM,MAAM,eAAe;AACnE,cAAM,IAAI;AAAA,UACR,6BAA6B,SAAS,MAAM,IAAI,SAAS,UAAU;AAAA,UACnE,SAAS;AAAA,UACT;AAAA,QACF;AAAA,MACF;AAEA,YAAM,OAAO,MAAM,SAAS,KAAK;AAEjC,UAAI,CAAC,KAAK,MAAM;AACd,cAAM,IAAI,eAAe,0CAA0C;AAAA,MACrE;AAEA,aAAO,KAAK;AAAA,IACd,SAAS,OAAO;AACd,UAAI,iBAAiB,aAAa;AAChC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,gCAAgC,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,QACtF;AAAA,QACA;AAAA,QACA,iBAAiB,QAAQ,QAAQ;AAAA,MACnC;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,KAAK,WAA2B;AAC9B,WAAO,cAAc,KAAK,YAAY,SAAS;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,WAAmB,OAA4C;AAC/E,QAAI;AACF,YAAM,UAA+B;AAAA,QACnC;AAAA,QACA;AAAA,QACA,cAAc,KAAK;AAAA,MACrB;AAEA,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,qBAAqB;AAAA,QAC/D,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU,OAAO;AAAA,MAC9B,CAAC;AAED,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,YAAY,MAAM,SAAS,KAAK,EAAE,MAAM,MAAM,eAAe;AACnE,cAAM,IAAI;AAAA,UACR,wBAAwB,SAAS,MAAM,IAAI,SAAS,UAAU;AAAA,UAC9D,SAAS;AAAA,UACT;AAAA,QACF;AAAA,MACF;AAEA,YAAM,OAAO,MAAM,SAAS,KAAK;AAGjC,aAAO;AAAA,QACL,UAAU,KAAK;AAAA,QACf,WAAW,KAAK;AAAA,QAChB,WAAW,KAAK;AAAA,QAChB,OAAO,KAAK;AAAA,QACZ,iBAAiB,KAAK;AAAA,QACtB,OAAO,KAAK;AAAA,QACZ;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,aAAa;AAChC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,2BAA2B,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,QACjF;AAAA,QACA;AAAA,QACA,iBAAiB,QAAQ,QAAQ;AAAA,MACnC;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAAsC;AAC1C,QAAI;AACF,YAAM,YAAY,MAAM,KAAK,iBAAiB;AAC9C,YAAM,QAAQ,KAAK,KAAK,SAAS;AACjC,YAAM,SAAS,MAAM,KAAK,YAAY,WAAW,KAAK;AAEtD,UAAI,CAAC,OAAO,UAAU;AACpB,cAAM,IAAI;AAAA,UACR,OAAO,SAAS;AAAA,QAClB;AAAA,MACF;AAEA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UAAI,iBAAiB,aAAa;AAChC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,wBAAwB,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,QAC9E,iBAAiB,QAAQ,QAAQ;AAAA,MACnC;AAAA,IACF;AAAA,EACF;AACF;","names":[]}